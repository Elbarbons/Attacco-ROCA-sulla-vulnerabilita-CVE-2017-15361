#Spiegazione matematica del fingerprinting:
#
#N = (k ∗ M + 65537a mod M) ∗ (l ∗ M + 65537b mod M) = p * q
#for a,b, k,l ∈ Z.
#N ≡ 65537^(a+b) ≡ 65537^c mod M per qualche c intero
#L'esistenza del logaritmo discreto The existence of the discrete logarithm
#c = log65537 N mod M è usato come fingerprinting del modulo pubblico n
#dalla RSALib

from sympy.ntheory.residue_ntheory import _discrete_log_pohlig_hellman
from sympy import primorial
from Keygen import bits_check

#e=0x10001=65537
e=0x10001

def fingprint(N):
#Fingerprinting della chiave fornita 'N'.
#Input: N, chiave pubblica
#Output: True or False, True=Chiave vulnerabile

    #Calcola il primoriale della chiave e con il logaritmo discreto di
    #pohlig-hellman calcolo l'esponente;
    #Se la funzione _discrete_log_pohlig_hellman(M,N,e) va a buon fine
    #la chiave è vulnerabile e ritorniamo True
    n=bits_check(N.bit_length())
    M=primorial(n)
    try:
        c=_discrete_log_pohlig_hellman(M,N,e)
        return True
    except:
        return False
