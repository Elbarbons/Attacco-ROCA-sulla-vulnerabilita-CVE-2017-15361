#Genera i numeri primi che compongono la chiave RSA partendo dalla
#lunghezza in bit della chiave(bits_key).

from math import log
from sympy import isprime
from sympy import primorial
from Cryptodome.Util.number import getRandomNBitInteger

# 0x10001 = 65537 (hardcoded public exponent, low hamming weight = fast)
e = 0x10001

#Spiegazione matematica:
#
#p=k*M+(65537^a)//M      p,q primi    N=p*q   phi(N)=(p-1)*(q-1)
#q=k*M+(65537^a)//M      'e' coprimo con phi(N) d=e^-1 mod phi(N)
#                        (e,N) chiave pubblica   (d,N) chiave privata
#                        M=produttoria dei primi n numeri primi(2*3..*Pn)
#
#
# bits in p,q    n       Pn
# 256...480      38      167
# 496...976      71      353
# 992...1968     126     701
# 1984...2048    224     1427
#
# es
# |N|=512 bits ===> p,q= |N|/2 = 256 bits ===> n=39 e |M|=219 bits
# |k|=|N|/2-|M|=37 bits |a|=log2(orderM(65537))=62


def bits_check(bits_key):
# Controlla la lunghezza di bit della chiave e restituisce 'n' per calcolare
# il primoriale; Se il valore non Ã¨ in range segnala un errore.
# Range bits chiave permesso 64-4096

    if   bits_key >=64   and bits_key <=128:
        return 9
    elif bits_key >=512  and bits_key<=960:
        return 38
    elif bits_key >=992  and bits_key<=1952:
        return 71
    elif bits_key >=1984 and bits_key<=3936:
        return 126
    elif bits_key >=3968 and bits_key<=4096:
        return 224
    else ValueError:
        print("Bits della chiave non in range")


def calculation_bits(bits_key,n):
#Calcola la lunghezza di bit per 'M', 'k' e 'a'.
#Input: lunghezza della chiave bits_key e 'n'
#Output: primoriale M e la lunghezza di bit di 'k' e 'a'

    bits_primes=int(bits_key/2)
    M=primorial(n)
    M_bits=M.bit_length()
    k_bits=bits_primes - M_bits
    a_dictionary = {9:28, 38: 62, 71: 134, 126: 255, 224: 434}
    a_bits=a_dictionary[n]
    return a_bits, k_bits, M

def generator_of_primes(a_bits,k_bits,M,bits_key):
#Genera i primi p e q basati sulla formula
#Input:a_bits,k_bits,M,bits_key
#Output:i numeri primi p,q e il loro prodotto N
    N=0
    while N.bit_length()!=bits_key:

        while True:
            a_p=getRandomNBitInteger(a_bits)
            k_p=getRandomNBitInteger(k_bits)
            p=k_p*M+pow(e,a_p,M)
            if isprime(p):
                break

        while True:
            a_q=getRandomNBitInteger(a_bits)
            k_q=getRandomNBitInteger(k_bits)
            q=k_q*M+pow(e,a_q,M)
            if isprime(q):
                break
        N=p*q
    return N,p,q

def GenVulnerableKeys(bits_key):
#Funzione principale del file da richiamare per generare
#chiavi RSA vulnerabili ad attacco ROCA.
#Input:bits_key, lunghezza chiave
#Output:N,p,q

    n=bits_check(bits_key)

    a_bits, k_bits, M = calculation_bits(bits_key,n)

    N,p,q=generator_of_primes(a_bits,k_bits,M,bits_key)

    return N,p,q
