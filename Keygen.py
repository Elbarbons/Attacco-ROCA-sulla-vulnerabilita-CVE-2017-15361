from math import log
from sympy import isprime
from sympy import primorial
from Cryptodome.Util.number import getRandomNBitInteger
# 0x10001 = 65537 (hardcoded public exponent, low hamming weight = fast)
# CHIEDERE
#In toeria la rappresentazione binaria di 65537 e' 0x10001 e il fatto che
#contenga solo due 1 rende il calcolo di 65537 molto piu' veloce;
#(e deve essere un primo; 3 e 17 sono altri due esempi)
e = 0x10001
#p=k*M+(65537^a)//M      p,q primi    N=p*q   phi(N)=(p-1)*(q-1)
#q=k*M+(65537^a)//M      e coprimo con phi(N) d=e^-1 mod phi(N)
#                        (e,N) chiave pubblica   (d,N) chiave privata
#                        M=produttoria dei primi n numeri primi(2*3..*Pn)
#
#
# bits in p,q    n       Pn
# 256...480      39      167
# 496...976      71      353
# 992...1968     126     701
# 1984...2048    225     1427
#
#
# |N|=512 bits ===> p,q= |N|/2 = 256 bits ===> n=39 e |M|=219 bits
# |k|=|N|/2-|M|=37 bits |a|=log2(orderM(65537))=62


def bits_check(bits_key):
# Controlla la lunghezza di bit della chiave e restituisce 'n' per calcolare
# il primoriale
# Range bits chiave permesso 512-4096
#
#MODIFICATO 39 A 38 E 225 A 224 !!

    if   bits_key >=64   and bits_key <=128:
        return 9
    elif bits_key >=512  and bits_key<=960:
        return 38
    elif bits_key >=992  and bits_key<=1952:
        return 71
    elif bits_key >=1984 and bits_key<=3936:
        return 126
    elif bits_key >=3968 and bits_key<=4096:
        return 224
    else:
        raise ErroreInput("Bits della chiave non in range")


def calculation_bits(bits_key,n):
#Calcola i bit per M, k, a
#Restituisce il primoriale M e i bit da cui devono essere formati k e a

    bits_primes=int(bits_key/2)
    M=primorial(n)
    M_bits=M.bit_length()
    k_bits=bits_primes - M_bits
    a_dictionary = {9:28, 38: 62, 71: 134, 126: 255, 224: 434}
    a_bits=a_dictionary[n]
    return a_bits, k_bits, M

def generator_of_primes(a_bits,k_bits,M,bits_key):
#Genera i primi p e q basati sulla formula e li restituisce
    N=0
    while N.bit_length()!=bits_key:

        while True:
            a_p=getRandomNBitInteger(a_bits)
            k_p=getRandomNBitInteger(k_bits)
            p=k_p*M+pow(e,a_p,M)
            if isprime(p):
                break

        while True:
            a_q=getRandomNBitInteger(a_bits)
            k_q=getRandomNBitInteger(k_bits)
            q=k_q*M+pow(e,a_q,M)
            if isprime(q):
                break
        N=p*q
    return N,p

def GenVulnerableKeys(bits_key):
#Genera chiavi RSA vulnerabili ad attacco ROCA

    n=bits_check(bits_key)

    a_bits, k_bits, M = calculation_bits(bits_key,n)

    N,p=generator_of_primes(a_bits,k_bits,M,bits_key)

    return N,p
