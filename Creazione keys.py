"""
===================
     TESI
===================



implementare:
-Generatore di chiavi
-Fingerprinting(capire se le chiavi sono del tipo giusto,
                cioe' ricavate usando quella formula)
-Attacco coppersmith
....
maybe confronti con altri tipi di attacchi
"""

"""
1. GENERATORE DI CHIAVI
"""
from random import getrandbits
from math import log
from sympy import isprime
from sympy import primorial

# 0x10001 = 65537 (hardcoded public exponent, low hamming weight = fast)
# CHIEDERE
#In toeria la rappresentazione binaria di 65537 e' 0x10001 e il fatto che
#contenga solo due 1 rende il calcolo di 65537 molto piu' veloce;
#(e deve essere un primo; 3 e 17 sono altri due esempi)
e = 0x10001

#p=k*M+(65537^a)//M      p,q primi    N=p*q   phi(N)=(p-1)*(q-1)
#q=k*M+(65537^a)//M      e coprimo con phi(N) d=e^-1 mod phi(N)
#                        (e,N) chiave pubblica   (d,N) chiave privata
#                        M=produttoria dei primi n numeri primi(2*3..*Pn)
#
#
# bits in p,q    n       Pn
# 256...480      39      167
# 496...976      71      353
# 992...1968     126     701
# 1984...2048    225     1427
#
#
# |N|=512 bits ===> p,q= |N|/2 = 256 bits ===> n=39 e |M|=219 bits
# |k|=|N|/2-|M|=37 bits |a|=log2(orderM(65537))=62


def bits_check(bits_chiave):
# Controlla la lunghezza di bit della chiave e restituisce n per calcolare
# il primoriale
# Range bits chiave 512-4096

    if bits_chiave >=512 and bits_chiave<=960:
        return 39
    elif bits_chiave >=992 and bits_chiave<=1952:
        return 71
    elif bits_chiave >=1984 and bits_chiave<=3936:
        return 126
    elif bits_chiave >=3968 and bits_chiave<=4096:
        return 225
    else:
        raise ErroreInput("Bits della chiave non in range")


def calcolo_bits(bits_chiave,n):
#Calcola i bit per M, k, a
#Restituisce il primoriale M e i bit da cui devono essere formati k e a

    bits_primi=int(bits_chiave/2)
    M=primorial(n)
    M_bits=int(log(M,2))
    k_bits=bits_primi - M_bits
    a_dictionary = {39: 62, 71: 134, 126: 255, 225: 434}
    a_bits=a_dictionary[n]
    return a_bits, k_bits, M


def generatore_di_primi(a_bits,k_bits,M):
#Genera i primi p e q basati sulla formula e li restituisce

    while True:
        a_p=getrandbits(a_bits)
        k_p=getrandbits(k_bits)
        p=k_p*M+pow(e,a_p,M)
        if isprime(p):
            break
    while True:
        a_q=getrandbits(a_bits)
        k_q=getrandbits(k_bits)
        q=k_q*M+pow(e,a_q,M)
        if isprime(q):
            break
    return p,q

def generare_chiavi_vulnerabili():
#Genera chiavi RSA vulnerabili ad attacco ROCA
    bits_chiave=input("Inserire lunghezza bit della chiave (Default=1024): ")

#Controllo del valore inserito in bits_chiave e castiamo int()
#Nessun valore inserito:usiamo il valore di Default
#Non numero: segnaliamo un errore
    if len(bits_chiave)== 0:
        bits_chiave=1024
    else:
        try:
            bits_chiave=int(bits_chiave)
        except:
            raise Errore("Non hai inserito un numero")

    n=bits_check(bits_chiave)

    a_bits, k_bits, M = calcolo_bits(bits_chiave,n)

    p,q=generatore_di_primi(a_bits,k_bits,M)

    N=p*q

    return N

N=generare_chiavi_vulnerabili()

#
#TEST
#
# generate only the public key (N, e), the whole point is to recover d
#from functools import reduce
#from math import log
#from operator import mul
#from os import remove
#from subprocess import check_output
#from Crypto.Util.number import getRandomNBitInteger, isPrime
#from Crypto.PublicKey import RSA

#rsa = RSA.construct((N, e))
#ascii_armored_key = rsa.exportKey().decode()
#print(ascii_armored_key)

# run it against the roca-detect check utility
#tmpfile = 'tmp.pub'
#with open(tmpfile, 'w') as f:
#    f.write(ascii_armored_key)
#print(check_output(['roca-detect', tmpfile]))
#remove(tmpfile)

#print(rsa)
